# 智能加工决策系统操作手册

**版本号：** V1.0  
**编写日期：** 2025年8月  
**适用系统：** 大模型智能加工决策问答系统

---

## 目录

1. [系统概述](#1-系统概述)
2. [系统架构](#2-系统架构)
3. [技术实现](#3-技术实现)
4. [环境配置](#4-环境配置)
5. [安装部署](#5-安装部署)
6. [系统使用](#6-系统使用)
7. [功能模块详解](#7-功能模块详解)
8. [API接口说明](#8-api接口说明)
9. [数据管理](#9-数据管理)
10. [故障排除](#10-故障排除)
11. [系统维护](#11-系统维护)
12. [附录](#12-附录)

---

## 1. 系统概述

### 1.1 系统简介

智能加工决策系统是一个基于知识图谱和大语言模型的智能制造决策支持系统。系统通过整合LightRAG知识检索、Neo4j图数据库和AI推理能力，为制造业提供智能化的工艺规划和刀具选择方案。

### 1.2 系统特点

- **智能化决策：** 结合规则引擎和大语言模型，提供准确的工艺推荐
- **知识图谱驱动：** 基于Neo4j构建的制造知识图谱，支持复杂关系查询
- **多模态参数提取：** 支持文本、规则和AI推理的多重参数提取方式
- **可扩展架构：** 模块化设计，便于功能扩展和系统集成

### 1.3 应用场景

- 制造企业的工艺规划辅助决策
- 刀具选型和参数优化建议
- 加工知识的智能检索和推荐
- 制造经验的知识化管理

### 1.4 技术优势

- **高准确性：** 多重验证机制确保推荐结果的准确性
- **强适应性：** 支持不同制造场景的个性化配置
- **易集成性：** 标准化API接口，便于与现有系统集成

---

## 2. 系统架构

### 2.1 整体架构

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   用户接口层    │    │    API接口层    │    │   AI摄像头接口  │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         └───────────────────────┼───────────────────────┘
                                 │
┌─────────────────────────────────────────────────────────────────┐
│                        智能决策引擎                              │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐  │
│  │   参数提取模块  │  │   知识检索模块  │  │   决策推荐模块  │  │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
         │                       │                       │
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   规则引擎库    │    │  LightRAG检索   │    │   Neo4j知识库   │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 2.2 核心组件

#### 2.2.1 智能决策引擎 (intelligent_machining_system.py)
- **功能：** 系统主控制器，协调各模块协同工作
- **职责：** 参数提取、LLM增强分析、知识上下文获取、决策生成

#### 2.2.2 知识检索模块 (lightrag_retrieval.py)
- **功能：** 基于LightRAG的知识图谱检索
- **职责：** 特征搜索、知识上下文获取、智能问答

#### 2.2.3 加工决策模块 (machining_advisor.py)
- **功能：** 工艺和刀具推荐决策
- **职责：** 工艺模板匹配、刀具选型、参数优化

#### 2.2.4 数据转换工具 (csv_to_neo4j.py)
- **功能：** CSV数据到Neo4j的转换
- **职责：** 数据导入、图谱构建、关系映射

#### 2.2.5 AI摄像头接口 (AICam_API.py)
- **功能：** 视觉识别接口
- **职责：** 图像处理、特征识别、参数提取

---

## 3. 技术实现

### 3.1 核心技术栈

#### 3.1.1 后端框架
- **Python 3.12.11：** 主要开发语言
- **asyncio：** 异步编程支持
- **logging：** 日志管理系统

#### 3.1.2 知识图谱技术
- **Neo4j：** 图数据库存储
- **LightRAG：** 知识检索框架
- **Cypher：** 图查询语言

#### 3.1.3 AI能力
- **派欧云API：** 大语言模型服务
- **scikit-learn：** 机器学习算法
- **gensim：** 自然语言处理

#### 3.1.4 数据处理
- **pandas：** 数据处理和分析
- **numpy：** 数值计算
- **scipy：** 科学计算

#### 3.1.5 图谱分析
- **networkx：** 网络分析
- **matplotlib：** 数据可视化
- **umap-learn：** 降维算法

### 3.2 算法实现

#### 3.2.1 多模态参数提取算法

```python
# 规则提取 + LLM分析 + 参数推断
def extract_parameters(self, question):
    # 1. 规则提取
    rule_params = self.rule_extractor.extract_parameters(question)
    
    # 2. LLM增强分析
    llm_params = await self.llm_enhanced_analysis(question, rule_params)
    
    # 3. 参数合并优化
    merged_params = self._merge_parameters(rule_params, llm_params)
    
    # 4. 缺失参数推断
    complete_params = self._infer_missing_parameters(merged_params)
    
    return complete_params
```

#### 3.2.2 智能推荐算法

```python
# 工艺模板匹配算法
def find_process_template(self, feature_name, surface_type, process_stage):
    query = """
    MATCH (t:工艺模板)
    WHERE t.特征名称 = $feature_name 
    AND t.特征面 = $surface_type 
    AND t.工序阶段 = $process_stage
    RETURN t
    """
    return self.db.run(query, parameters)

# 刀具匹配算法  
def find_suitable_tools(self, diameter_limit, workpiece_height):
    query = """
    MATCH (tool:刀具)
    WHERE tool.直径 <= $diameter_limit
    AND tool.伸出长度 >= $workpiece_height * 1.2
    RETURN tool
    ORDER BY tool.直径 DESC
    """
    return self.db.run(query, parameters)
```

#### 3.2.3 知识图谱构建算法

```python
# 节点创建算法
def create_nodes(self, df, node_type):
    for _, row in df.iterrows():
        node_data = row.to_dict()
        self.create_node(node_type, node_data)

# 关系映射算法
def create_relationships(self, source_df, target_df, relationship_type):
    for _, row in source_df.iterrows():
        source_id = row['id']
        target_id = self.find_matching_target(row, target_df)
        if target_id:
            self.create_relationship(source_id, target_id, relationship_type)
```

### 3.3 数据流处理

#### 3.3.1 数据流架构

```
用户问题 → 参数提取 → 知识检索 → 决策推理 → 结果生成
    ↓           ↓           ↓           ↓           ↓
规则引擎    LLM分析    图谱查询    算法匹配    格式化输出
    ↓           ↓           ↓           ↓           ↓
参数验证    上下文获取  关系推理    结果优化    JSON响应
```

#### 3.3.2 处理流程

1. **问题预处理：** 文本清洗、格式标准化
2. **参数提取：** 多重提取方式并行执行
3. **知识检索：** 图谱查询和向量检索
4. **决策推理：** 规则匹配和AI推理结合
5. **结果后处理：** 格式化、验证、排序

---

## 4. 环境配置

### 4.1 系统要求

#### 4.1.1 硬件要求
- **CPU：** 4核心以上，推荐8核心
- **内存：** 8GB以上，推荐16GB
- **存储：** 50GB可用空间
- **网络：** 稳定的互联网连接（用于LLM API调用）

#### 4.1.2 软件要求
- **操作系统：** Windows 10/11, Linux, macOS
- **Python：** 3.12.11或更高版本
- **Neo4j：** 4.0或更高版本
- **Git：** 版本控制工具

### 4.2 依赖环境

#### 4.2.1 Conda环境配置

```yaml
name: zxf-jog
channels:
  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/
  - defaults
dependencies:
  - python=3.12.11
  - pip
  - requests
  - setuptools
  - pip:
    - lightrag-hku
    - scikit-learn
    - scipy
    - matplotlib
    - networkx
    - gensim
    - numba
    - umap-learn
    - neo4j
    - pandas
    - numpy
    - asyncio
```

#### 4.2.2 环境创建命令

```bash
# 创建Conda环境
conda env create -f env.yml

# 激活环境
conda activate zxf-jog

# 验证安装
python -c "import lightrag; print('LightRAG installed successfully')"
```

### 4.3 配置文件

#### 4.3.1 主配置文件 (config.ini)

```ini
[neo4j]
uri = bolt://localhost:7687
username = neo4j
password = your_password
database = machining_db

[paiyun_api]
api_key = your_api_key
base_url = https://api.paiyun.com
model = gpt-4

[system]
log_level = INFO
log_file = system.log
temp_dir = temp/
max_retry = 3

[machining]
default_material = Steel
default_surface = 外表面
default_stage = 粗加工
```

---

## 5. 安装部署

### 5.1 系统安装

#### 5.1.1 代码获取

```bash
# 克隆项目代码
git clone https://github.com/your-repo/intelligent-machining-system.git
cd intelligent-machining-system

# 检查文件结构
ls -la
```

#### 5.1.2 依赖安装

```bash
# 安装Python依赖
pip install -r requirements.txt

# 验证核心依赖
python -c "import neo4j, lightrag, pandas; print('Dependencies OK')"
```

### 5.2 数据库部署

#### 5.2.1 Neo4j安装配置

```bash
# 下载Neo4j Community Edition
wget https://neo4j.com/artifact.php?name=neo4j-community-4.4.0-unix.tar.gz

# 解压安装
tar -xzf neo4j-community-4.4.0-unix.tar.gz
cd neo4j-community-4.4.0

# 启动Neo4j
./bin/neo4j start

# 访问Web界面
http://localhost:7474
```

#### 5.2.2 数据库初始化

```bash
# 运行数据导入脚本
python csv_to_neo4j.py --config config.ini

# 验证数据导入
python -c "
from neo4j import GraphDatabase
driver = GraphDatabase.driver('bolt://localhost:7687', auth=('neo4j', 'password'))
with driver.session() as session:
    result = session.run('MATCH (n) RETURN count(n) as count')
    print(f'Total nodes: {result.single()[\"count\"]}')
"
```

### 5.3 服务启动

#### 5.3.1 主服务启动

```bash
# 启动智能决策系统
python intelligent_machining_system.py

# 后台运行
nohup python intelligent_machining_system.py > system.log 2>&1 &
```

#### 5.3.2 API服务启动

```bash
# 启动API服务
python AICam_API.py --port 8080

# 验证API服务
curl http://localhost:8080/health
```

---

## 6. 系统使用

### 6.1 基本使用流程

#### 6.1.1 系统启动

1. **启动Neo4j数据库**
```bash
./neo4j-community-4.4.0/bin/neo4j start
```

2. **启动主系统**
```bash
conda activate zxf-jog
python intelligent_machining_system.py
```

3. **验证系统状态**
```bash
# 检查日志
tail -f system.log

# 测试连接
python -c "
import asyncio
from intelligent_machining_system import IntelligentMachiningSystem
async def test():
    system = IntelligentMachiningSystem('config.ini')
    result = await system.process_machining_question('加工直径50mm的孔需要什么刀具？')
    print(result)
asyncio.run(test())
"
```

#### 6.1.2 问题提交

系统支持多种方式的问题提交：

1. **文本问题提交**
```python
question = "加工直径30mm，深度50mm的孔，材料为铝合金，需要什么刀具和工艺？"
result = await system.process_machining_question(question)
```

2. **结构化参数提交**
```python
parameters = {
    "feature_name": "孔",
    "diameter": 30,
    "depth": 50,
    "material": "铝合金",
    "surface_type": "内表面",
    "process_stage": "粗加工"
}
result = await system.get_machining_recommendation(parameters)
```

### 6.2 功能使用示例

#### 6.2.1 工艺推荐查询

```python
# 示例1：基本工艺查询
question1 = "加工外圆，直径100mm，粗加工阶段用什么工艺？"
result1 = await system.process_machining_question(question1)
print("推荐工艺模板ID:", result1["template_id"])
print("加工工艺:", result1["machining_process"])

# 示例2：复杂特征加工
question2 = "铣削槽宽20mm，深度15mm，长度200mm的键槽"
result2 = await system.process_machining_question(question2)
print("推荐刀具ID:", result2["tool_id"])
print("工艺参数:", result2["process_parameters"])
```

#### 6.2.2 刀具选型查询

```python
# 示例3：刀具推荐
question3 = "加工深孔，直径8mm，深度120mm，需要什么钻头？"
result3 = await system.process_machining_question(question3)
print("推荐刀具:", result3["recommended_tools"])
print("刀具规格:", result3["tool_specifications"])
```

### 6.3 结果解读

#### 6.3.1 标准化响应格式

```json
{
    "template_id": "T001",
    "machining_process": "粗铣→半精铣→精铣",
    "tool_id": "D025_HSS",
    "parameters": {
        "spindle_speed": 1200,
        "feed_rate": 300,
        "cutting_depth": 2.0
    },
    "confidence": 0.95,
    "alternatives": [
        {
            "tool_id": "D025_CARBIDE",
            "confidence": 0.88
        }
    ]
}
```

#### 6.3.2 字段说明

- **template_id：** 推荐的工艺模板编号
- **machining_process：** 具体的加工工艺流程
- **tool_id：** 推荐的主要刀具编号
- **parameters：** 推荐的工艺参数
- **confidence：** 推荐结果的置信度
- **alternatives：** 备选方案

---

## 7. 功能模块详解

### 7.1 参数提取模块

#### 7.1.1 规则提取器

```python
class RuleExtractor:
    def __init__(self):
        self.dimension_patterns = [
            r'直径(\d+(?:\.\d+)?)mm',
            r'宽度(\d+(?:\.\d+)?)mm',
            r'长度(\d+(?:\.\d+)?)mm'
        ]
        self.feature_patterns = [
            r'(孔|槽|外圆|内孔|键槽)',
            r'(铣削|钻削|车削|镗削)'
        ]
    
    def extract_parameters(self, text):
        params = {}
        
        # 提取尺寸信息
        for pattern in self.dimension_patterns:
            match = re.search(pattern, text)
            if match:
                dimension_type = pattern.split('(')[0]
                params[dimension_type] = float(match.group(1))
        
        # 提取特征信息
        for pattern in self.feature_patterns:
            match = re.search(pattern, text)
            if match:
                params['feature'] = match.group(1)
        
        return params
```

#### 7.1.2 LLM增强分析

```python
async def llm_enhanced_analysis(self, question, initial_params):
    prompt = f"""
    作为制造工艺专家，请分析以下加工问题并提取关键参数：
    
    问题：{question}
    已提取参数：{initial_params}
    
    请以JSON格式返回完整的参数信息，包括：
    - feature_name: 特征名称
    - dimensions: 尺寸信息
    - material: 材料
    - surface_type: 表面类型
    - process_stage: 工序阶段
    """
    
    response = await self.llm_client.generate(prompt)
    return json.loads(response)
```

### 7.2 知识检索模块

#### 7.2.1 Neo4j知识检索器

```python
class Neo4jKnowledgeRetriever:
    def __init__(self, config):
        self.driver = GraphDatabase.driver(
            config['uri'],
            auth=(config['username'], config['password'])
        )
    
    def search_features(self, feature_name, limit=10):
        query = """
        MATCH (f:特征)
        WHERE f.名称 CONTAINS $feature_name
        RETURN f
        LIMIT $limit
        """
        
        with self.driver.session() as session:
            result = session.run(query, {
                'feature_name': feature_name,
                'limit': limit
            })
            return [record['f'] for record in result]
    
    def get_related_processes(self, feature_id):
        query = """
        MATCH (f:特征)-[:适用工艺]->(p:工艺)
        WHERE f.id = $feature_id
        RETURN p
        """
        
        with self.driver.session() as session:
            result = session.run(query, {'feature_id': feature_id})
            return [record['p'] for record in result]
```

#### 7.2.2 LightRAG集成

```python
from lightrag import LightRAG

class LightRAGRetriever:
    def __init__(self, config):
        self.rag = LightRAG(
            working_dir=config['working_dir'],
            llm_model_func=self.llm_model_func
        )
    
    async def query_knowledge(self, question, mode="hybrid"):
        response = await self.rag.aquery(
            question, 
            param=QueryParam(mode=mode)
        )
        return response
    
    def llm_model_func(self, prompt, system_prompt=None, **kwargs):
        # 集成派欧云API
        return self.paiyun_client.generate(prompt, system_prompt)
```

### 7.3 决策推荐模块

#### 7.3.1 工艺模板匹配

```python
class ProcessMatcher:
    def __init__(self, db_connection):
        self.db = db_connection
    
    def find_process_template(self, feature_name, surface_type, process_stage):
        query = """
        MATCH (t:工艺模板)
        WHERE t.特征名称 = $feature_name 
        AND t.特征面 = $surface_type 
        AND t.工序阶段 = $process_stage
        RETURN t
        ORDER BY t.适用性评分 DESC
        LIMIT 5
        """
        
        result = self.db.run(query, {
            'feature_name': feature_name,
            'surface_type': surface_type,
            'process_stage': process_stage
        })
        
        templates = []
        for record in result:
            template = record['t']
            templates.append({
                'id': template['id'],
                'name': template['name'],
                'process_steps': template['process_steps'],
                'applicability_score': template['适用性评分']
            })
        
        return templates
```

#### 7.3.2 刀具智能匹配

```python
class ToolMatcher:
    def __init__(self, db_connection):
        self.db = db_connection
    
    def find_suitable_tools(self, diameter_limit, workpiece_height):
        query = """
        MATCH (tool:刀具)
        WHERE tool.直径 <= $diameter_limit
        AND tool.伸出长度 >= $workpiece_height * 1.2
        RETURN tool, 
               (tool.直径 / $diameter_limit) as diameter_ratio,
               (tool.伸出长度 / ($workpiece_height * 1.2)) as length_ratio
        ORDER BY diameter_ratio DESC, length_ratio ASC
        LIMIT 10
        """
        
        result = self.db.run(query, {
            'diameter_limit': diameter_limit,
            'workpiece_height': workpiece_height
        })
        
        tools = []
        for record in result:
            tool = record['tool']
            tools.append({
                'id': tool['id'],
                'name': tool['name'],
                'diameter': tool['直径'],
                'length': tool['伸出长度'],
                'material': tool['材质'],
                'suitability_score': self.calculate_suitability(
                    record['diameter_ratio'], 
                    record['length_ratio']
                )
            })
        
        return tools
    
    def calculate_suitability(self, diameter_ratio, length_ratio):
        # 直径利用率权重0.7，长度适配权重0.3
        score = diameter_ratio * 0.7 + (1 / length_ratio) * 0.3
        return min(score, 1.0)
```

### 7.4 结果生成模块

#### 7.4.1 智能答案生成

```python
class AnswerGenerator:
    def __init__(self, llm_client):
        self.llm_client = llm_client
    
    async def generate_intelligent_answer(self, question, context, recommendation):
        prompt = f"""
        作为制造工艺专家，请基于以下信息生成专业的加工建议：
        
        用户问题：{question}
        知识上下文：{context}
        系统推荐：{recommendation}
        
        请生成详细的加工建议，包括：
        1. 工艺分析
        2. 刀具选择理由
        3. 参数设置建议
        4. 注意事项
        
        要求：专业、准确、实用
        """
        
        response = await self.llm_client.generate(prompt)
        return response
    
    def generate_standardized_answer(self, recommendation):
        return {
            "template_id": recommendation.get("template_id"),
            "machining_process": recommendation.get("process_steps"),
            "tool_id": recommendation.get("primary_tool_id"),
            "process_parameters": {
                "spindle_speed": recommendation.get("spindle_speed"),
                "feed_rate": recommendation.get("feed_rate"),
                "cutting_depth": recommendation.get("cutting_depth")
            },
            "confidence": recommendation.get("confidence_score", 0.0),
            "reasoning": recommendation.get("reasoning", "")
        }
```

---

## 8. API接口说明

### 8.1 RESTful API接口

#### 8.1.1 问题处理接口

**接口URL：** `POST /api/v1/machining/question`

**请求参数：**
```json
{
    "question": "加工直径30mm的孔需要什么刀具？",
    "context": {
        "material": "铝合金",
        "workpiece_height": 50
    },
    "options": {
        "include_alternatives": true,
        "detail_level": "detailed"
    }
}
```

**响应格式：**
```json
{
    "status": "success",
    "data": {
        "template_id": "T001",
        "machining_process": "钻削→扩孔→精镗",
        "tool_id": "D030_HSS_DRILL",
        "parameters": {
            "spindle_speed": 800,
            "feed_rate": 200,
            "cutting_depth": 15
        },
        "confidence": 0.92,
        "alternatives": [...]
    },
    "execution_time": 1.23
}
```

#### 8.1.2 参数推荐接口

**接口URL：** `POST /api/v1/machining/recommend`

**请求参数：**
```json
{
    "feature_name": "孔",
    "dimensions": {
        "diameter": 30,
        "depth": 50
    },
    "material": "铝合金",
    "surface_type": "内表面",
    "process_stage": "粗加工"
}
```

#### 8.1.3 知识查询接口

**接口URL：** `GET /api/v1/knowledge/search`

**查询参数：**
- `q`: 查询关键词
- `type`: 查询类型 (process/tool/material)
- `limit`: 返回结果数量限制

### 8.2 AI摄像头API

#### 8.2.1 图像识别接口

**接口URL：** `POST /api/v1/vision/analyze`

**请求格式：**
```json
{
    "image": "base64_encoded_image",
    "analysis_type": "feature_detection",
    "options": {
        "detect_dimensions": true,
        "identify_material": false
    }
}
```

**响应格式：**
```json
{
    "status": "success",
    "features": [
        {
            "type": "孔",
            "diameter": 30.5,
            "depth": 45.2,
            "confidence": 0.95
        }
    ],
    "dimensions": {
        "width": 100,
        "height": 50,
        "thickness": 20
    }
}
```

### 8.3 错误处理

#### 8.3.1 错误响应格式

```json
{
    "status": "error",
    "error_code": "E001",
    "error_message": "参数提取失败",
    "details": {
        "field": "diameter",
        "reason": "无法从输入中提取有效的直径信息"
    },
    "timestamp": "2024-12-20T10:30:00Z"
}
```

#### 8.3.2 常见错误代码

- **E001：** 参数提取失败
- **E002：** 数据库连接错误
- **E003：** LLM API调用失败
- **E004：** 知识库查询超时
- **E005：** 推荐结果置信度过低

---

## 9. 数据管理

### 9.1 数据导入

#### 9.1.1 CSV数据格式

**工艺模板数据格式：**
```csv
id,特征名称,特征面,工序阶段,工艺步骤,适用性评分
T001,孔,内表面,粗加工,钻削→扩孔,0.95
T002,槽,内表面,精加工,粗铣→精铣,0.88
```

**刀具数据格式：**
```csv
id,name,直径,伸出长度,材质,适用材料
D001,高速钢钻头,10,80,HSS,铝合金;钢材
D002,硬质合金立铣刀,25,100,Carbide,钢材;铸铁
```

#### 9.1.2 数据导入命令

```bash
# 导入工艺模板数据
python csv_to_neo4j.py --type template --file data/templates.csv

# 导入刀具数据
python csv_to_neo4j.py --type tool --file data/tools.csv

# 批量导入
python csv_to_neo4j.py --batch-import data/

# 验证导入结果
python csv_to_neo4j.py --verify
```

### 9.2 数据备份与恢复

#### 9.2.1 数据备份

```bash
# Neo4j数据备份
neo4j-admin dump --database=machining_db --to=backup/machining_backup.dump

# 配置文件备份
cp config.ini backup/config_backup.ini

# 创建完整备份脚本
./scripts/backup_system.sh
```

#### 9.2.2 数据恢复

```bash
# 停止Neo4j服务
neo4j stop

# 恢复数据库
neo4j-admin load --from=backup/machining_backup.dump --database=machining_db --force

# 启动服务
neo4j start

# 验证恢复
python scripts/verify_restore.py
```

### 9.3 数据维护

#### 9.3.1 定期维护任务

```bash
# 创建定时任务
crontab -e

# 添加以下任务
# 每日凌晨2点备份数据
0 2 * * * /path/to/backup_system.sh

# 每周日凌晨3点清理日志
0 3 * * 0 /path/to/cleanup_logs.sh

# 每月1号更新知识库索引
0 4 1 * * /path/to/update_index.sh
```

#### 9.3.2 数据质量监控

```python
# 数据质量检查脚本
def check_data_quality():
    # 检查节点完整性
    missing_nodes = check_missing_nodes()
    
    # 检查关系一致性
    inconsistent_relations = check_relation_consistency()
    
    # 检查数据重复
    duplicate_records = check_duplicates()
    
    # 生成质量报告
    generate_quality_report(missing_nodes, inconsistent_relations, duplicate_records)
```

---

## 10. 故障排除

### 10.1 常见问题诊断

#### 10.1.1 系统启动问题

**问题：** 系统启动时连接Neo4j失败

**原因分析：**
- Neo4j服务未启动
- 连接配置错误
- 认证信息错误

**解决步骤：**
```bash
# 1. 检查Neo4j状态
neo4j status

# 2. 启动Neo4j服务
neo4j start

# 3. 验证连接配置
python -c "
from neo4j import GraphDatabase
try:
    driver = GraphDatabase.driver('bolt://localhost:7687', auth=('neo4j', 'password'))
    driver.verify_connectivity()
    print('Connection successful')
except Exception as e:
    print(f'Connection failed: {e}')
"

# 4. 检查配置文件
cat config.ini | grep -A 5 "\[neo4j\]"
```

#### 10.1.2 LLM API调用问题

**问题：** LLM API调用超时或失败

**原因分析：**
- 网络连接问题
- API密钥错误
- 请求频率限制

**解决步骤：**
```bash
# 1. 测试网络连接
curl -I https://api.paiyun.com

# 2. 验证API密钥
python -c "
import requests
headers = {'Authorization': 'Bearer your_api_key'}
response = requests.get('https://api.paiyun.com/v1/models', headers=headers)
print(f'Status: {response.status_code}')
"

# 3. 检查请求频率
tail -f system.log | grep "API_RATE_LIMIT"

# 4. 调整重试策略
# 在config.ini中增加重试配置
echo "
[api]
max_retries = 5
retry_delay = 2
timeout = 30
" >> config.ini
```

### 10.2 性能优化

#### 10.2.1 数据库性能优化

```cypher
-- 创建索引优化查询性能
CREATE INDEX feature_name_index FOR (f:特征) ON (f.名称);
CREATE INDEX tool_diameter_index FOR (t:刀具) ON (t.直径);
CREATE INDEX template_stage_index FOR (tp:工艺模板) ON (tp.工序阶段);

-- 查询计划分析
EXPLAIN MATCH (t:工艺模板) WHERE t.特征名称 = "孔" RETURN t;

-- 统计信息更新
CALL db.stats.retrieve('GRAPH COUNTS');
```

#### 10.2.2 系统性能监控

```python
# 性能监控脚本
import time
import psutil
import logging

class PerformanceMonitor:
    def __init__(self):
        self.logger = logging.getLogger('performance')
    
    def monitor_system_resources(self):
        cpu_percent = psutil.cpu_percent()
        memory_percent = psutil.virtual_memory().percent
        disk_usage = psutil.disk_usage('/').percent
        
        self.logger.info(f"CPU: {cpu_percent}%, Memory: {memory_percent}%, Disk: {disk_usage}%")
        
        if cpu_percent > 80:
            self.logger.warning("High CPU usage detected")
        if memory_percent > 85:
            self.logger.warning("High memory usage detected")
    
    def monitor_response_time(self, function):
        def wrapper(*args, **kwargs):
            start_time = time.time()
            result = function(*args, **kwargs)
            end_time = time.time()
            
            execution_time = end_time - start_time
            self.logger.info(f"{function.__name__} execution time: {execution_time:.2f}s")
            
            if execution_time > 5:
                self.logger.warning(f"Slow execution detected: {function.__name__}")
            
            return result
        return wrapper
```

### 10.3 日志分析

#### 10.3.1 日志配置

```python
import logging
import logging.handlers

def setup_logging():
    # 创建日志器
    logger = logging.getLogger()
    logger.setLevel(logging.INFO)
    
    # 文件处理器（按大小轮转）
    file_handler = logging.handlers.RotatingFileHandler(
        'system.log', 
        maxBytes=10*1024*1024,  # 10MB
        backupCount=5
    )
    file_handler.setLevel(logging.INFO)
    
    # 控制台处理器
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.WARNING)
    
    # 日志格式
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    file_handler.setFormatter(formatter)
    console_handler.setFormatter(formatter)
    
    # 添加处理器
    logger.addHandler(file_handler)
    logger.addHandler(console_handler)
```

#### 10.3.2 关键日志分析

```bash
# 查看错误日志
grep "ERROR" system.log | tail -20

# 分析API调用频率
grep "API_CALL" system.log | awk '{print $1}' | uniq -c

# 监控响应时间
grep "execution_time" system.log | awk '{print $NF}' | sort -n | tail -10

# 查看内存使用情况
grep "Memory" system.log | tail -20
```

---

## 11. 系统维护

### 11.1 定期维护任务

#### 11.1.1 日常维护检查表

**每日检查：**
- [ ] 系统服务状态
- [ ] 错误日志审查
- [ ] 数据库连接状态
- [ ] API调用成功率
- [ ] 系统响应时间

**每周检查：**
- [ ] 数据库性能分析
- [ ] 日志文件轮转
- [ ] 系统资源使用率
- [ ] 知识库更新状态
- [ ] 备份完整性验证

**每月检查：**
- [ ] 系统性能基准测试
- [ ] 数据质量评估
- [ ] 安全补丁更新
- [ ] 知识库内容审核
- [ ] 用户反馈分析

#### 11.1.2 维护脚本

```bash
#!/bin/bash
# daily_maintenance.sh - 日常维护脚本

echo "开始日常维护检查..."

# 检查系统状态
echo "1. 检查系统服务状态..."
systemctl status neo4j
python -c "import requests; print('API服务状态:', requests.get('http://localhost:8080/health').status_code)"

# 检查日志错误
echo "2. 检查错误日志..."
error_count=$(grep -c "ERROR" /var/log/system.log)
if [ $error_count -gt 10 ]; then
    echo "警告: 发现 $error_count 个错误，需要关注"
fi

# 检查磁盘空间
echo "3. 检查磁盘空间..."
df -h | grep -E "(8[0-9]|9[0-9])%" && echo "警告: 磁盘空间不足"

# 检查数据库连接
echo "4. 检查数据库连接..."
python -c "
from neo4j import GraphDatabase
try:
    driver = GraphDatabase.driver('bolt://localhost:7687', auth=('neo4j', 'password'))
    with driver.session() as session:
        result = session.run('RETURN 1')
        print('数据库连接正常')
except Exception as e:
    print(f'数据库连接失败: {e}')
"

echo "日常维护检查完成"
```

### 11.2 系统更新

#### 11.2.1 版本更新流程

```bash
# 1. 备份当前系统
./scripts/backup_system.sh

# 2. 下载新版本
git fetch origin
git checkout v2.0.0

# 3. 更新依赖
conda env update -f env.yml

# 4. 数据库迁移（如需要）
python scripts/migrate_database.py --from-version 1.0 --to-version 2.0

# 5. 配置文件更新
python scripts/update_config.py

# 6. 运行测试
python -m pytest tests/

# 7. 重启服务
./scripts/restart_services.sh

# 8. 验证更新
python scripts/verify_update.py
```

#### 11.2.2 回滚计划

```bash
# 版本回滚脚本
#!/bin/bash
# rollback.sh

echo "开始系统回滚..."

# 1. 停止当前服务
./scripts/stop_services.sh

# 2. 恢复代码版本
git checkout v1.0.0

# 3. 恢复数据库
neo4j-admin load --from=backup/pre_update_backup.dump --database=machining_db --force

# 4. 恢复配置文件
cp backup/config_backup.ini config.ini

# 5. 重启服务
./scripts/start_services.sh

# 6. 验证回滚
python scripts/verify_rollback.py

echo "系统回滚完成"
```

### 11.3 安全维护

#### 11.3.1 安全检查

```bash
# 安全检查脚本
#!/bin/bash
# security_check.sh

echo "开始安全检查..."

# 1. 检查默认密码
echo "1. 检查默认密码使用情况..."
grep -r "password\|123456\|admin" config/ && echo "警告: 发现可能的默认密码"

# 2. 检查文件权限
echo "2. 检查敏感文件权限..."
find . -name "*.ini" -o -name "*.conf" | xargs ls -la

# 3. 检查开放端口
echo "3. 检查开放端口..."
netstat -tuln | grep -E ":7687|:8080"

# 4. 检查SSL证书（如适用）
echo "4. 检查SSL证书..."
openssl x509 -in certs/server.crt -text -noout | grep "Not After" || echo "无SSL证书或证书路径错误"

echo "安全检查完成"
```

#### 11.3.2 访问日志审计

```python
# 访问日志审计脚本
import re
import json
from collections import defaultdict, Counter
from datetime import datetime, timedelta

class AccessLogAuditor:
    def __init__(self, log_file):
        self.log_file = log_file
        self.suspicious_patterns = [
            r'SELECT.*FROM.*WHERE.*OR.*1=1',  # SQL注入
            r'<script.*>.*</script>',         # XSS攻击
            r'\.\./',                         # 路径遍历
            r'eval\(',                        # 代码注入
        ]
    
    def analyze_access_patterns(self):
        ip_counts = Counter()
        endpoint_counts = Counter()
        error_counts = Counter()
        
        with open(self.log_file, 'r') as f:
            for line in f:
                try:
                    log_entry = json.loads(line)
                    ip = log_entry.get('client_ip')
                    endpoint = log_entry.get('endpoint')
                    status = log_entry.get('status_code')
                    
                    if ip:
                        ip_counts[ip] += 1
                    if endpoint:
                        endpoint_counts[endpoint] += 1
                    if status >= 400:
                        error_counts[status] += 1
                        
                except json.JSONDecodeError:
                    continue
        
        # 检测异常访问
        self.detect_anomalies(ip_counts, endpoint_counts, error_counts)
    
    def detect_anomalies(self, ip_counts, endpoint_counts, error_counts):
        # 检测高频访问IP
        avg_requests = sum(ip_counts.values()) / len(ip_counts)
        for ip, count in ip_counts.most_common(10):
            if count > avg_requests * 5:
                print(f"警告: IP {ip} 异常高频访问 ({count} 次)")
        
        # 检测错误率异常
        total_requests = sum(endpoint_counts.values())
        total_errors = sum(error_counts.values())
        error_rate = total_errors / total_requests if total_requests > 0 else 0
        
        if error_rate > 0.1:  # 错误率超过10%
            print(f"警告: 系统错误率异常 ({error_rate:.2%})")
```

---

## 12. 附录

### 12.1 配置参数详解

#### 12.1.1 Neo4j配置参数

```ini
[neo4j]
# 数据库连接URI
uri = bolt://localhost:7687

# 认证信息
username = neo4j
password = your_secure_password

# 数据库名称
database = machining_db

# 连接池配置
max_connection_pool_size = 50
connection_acquisition_timeout = 60

# 事务配置
transaction_timeout = 60
max_transaction_retry_time = 30
```

#### 12.1.2 LLM API配置参数

```ini
[paiyun_api]
# API密钥
api_key = your_api_key_here

# API基础URL
base_url = https://api.paiyun.com/v1

# 使用的模型
model = gpt-4-turbo

# 请求配置
max_tokens = 2048
temperature = 0.7
timeout = 30
max_retries = 3
retry_delay = 1
```

#### 12.1.3 系统配置参数

```ini
[system]
# 日志级别 (DEBUG, INFO, WARNING, ERROR, CRITICAL)
log_level = INFO

# 日志文件路径
log_file = logs/system.log

# 临时文件目录
temp_dir = temp/

# 最大重试次数
max_retry = 3

# 并发处理数量
max_concurrent_requests = 10

# 缓存配置
enable_cache = true
cache_expire_time = 3600
```

### 12.2 数据库架构

#### 12.2.1 节点类型定义

**特征节点 (Feature)**
```
属性:
- id: 唯一标识符
- 名称: 特征名称 (如：孔、槽、外圆)
- 类型: 特征类型 (几何特征、工艺特征)
- 描述: 特征描述
```

**工艺模板节点 (ProcessTemplate)**
```
属性:
- id: 模板唯一标识符
- 特征名称: 适用特征
- 特征面: 表面类型 (内表面、外表面)
- 工序阶段: 加工阶段 (粗加工、精加工)
- 工艺步骤: 具体工艺流程
- 适用性评分: 适用程度评分
```

**刀具节点 (Tool)**
```
属性:
- id: 刀具唯一标识符
- name: 刀具名称
- 直径: 刀具直径 (mm)
- 伸出长度: 刀具伸出长度 (mm)
- 材质: 刀具材质 (HSS, Carbide等)
- 适用材料: 适用工件材料
- 最大转速: 推荐最大转速 (rpm)
```

#### 12.2.2 关系类型定义

**适用工艺关系 (SUITABLE_PROCESS)**
```
连接: 特征 -> 工艺模板
属性:
- 适用度: 适用程度 (0-1)
- 优先级: 推荐优先级
```

**推荐刀具关系 (RECOMMENDED_TOOL)**
```
连接: 工艺模板 -> 刀具
属性:
- 推荐度: 推荐程度 (0-1)
- 应用场景: 具体应用描述
```

**材料适配关系 (MATERIAL_COMPATIBILITY)**
```
连接: 刀具 -> 材料
属性:
- 兼容性: 兼容程度 (0-1)
- 切削参数: 推荐切削参数
```

### 12.3 错误代码参考

#### 12.3.1 系统错误代码

| 错误代码 | 错误类型 | 描述 | 解决方案 |
|---------|---------|------|---------|
| E001 | 参数提取错误 | 无法从输入中提取有效参数 | 检查输入格式，补充必要信息 |
| E002 | 数据库连接错误 | Neo4j数据库连接失败 | 检查数据库服务状态和配置 |
| E003 | LLM API错误 | 大语言模型API调用失败 | 检查网络连接和API密钥 |
| E004 | 知识库查询错误 | 知识库查询超时或失败 | 检查数据库性能和查询语句 |
| E005 | 推荐置信度低 | 推荐结果置信度低于阈值 | 补充输入信息或调整阈值 |
| E006 | 配置文件错误 | 配置文件格式错误或缺失 | 检查配置文件语法和完整性 |
| E007 | 权限错误 | 访问权限不足 | 检查文件和目录权限设置 |
| E008 | 资源不足 | 系统资源不足 | 释放资源或升级硬件配置 |

#### 12.3.2 业务逻辑错误代码

| 错误代码 | 错误类型 | 描述 | 解决方案 |
|---------|---------|------|---------|
| B001 | 特征识别失败 | 无法识别输入的加工特征 | 使用标准特征名称或提供更多描述 |
| B002 | 尺寸参数无效 | 提取的尺寸参数超出合理范围 | 检查输入的尺寸数值 |
| B003 | 工艺模板缺失 | 没有找到匹配的工艺模板 | 扩充知识库或使用相似工艺 |
| B004 | 刀具匹配失败 | 没有找到合适的刀具 | 调整尺寸要求或扩充刀具库 |
| B005 | 材料不支持 | 指定材料不在支持范围内 | 使用支持的材料或扩充材料库 |

### 12.4 性能基准

#### 12.4.1 响应时间基准

| 操作类型 | 期望响应时间 | 可接受响应时间 | 超时阈值 |
|---------|-------------|---------------|---------|
| 简单参数提取 | < 0.5秒 | < 1秒 | 3秒 |
| 复杂问题分析 | < 2秒 | < 5秒 | 10秒 |
| 知识库查询 | < 1秒 | < 3秒 | 8秒 |
| 工艺推荐生成 | < 3秒 | < 8秒 | 15秒 |
| 完整问题处理 | < 5秒 | < 12秒 | 30秒 |

#### 12.4.2 系统资源使用基准

| 资源类型 | 正常使用率 | 警告阈值 | 临界阈值 |
|---------|-----------|---------|---------|
| CPU使用率 | < 50% | 70% | 85% |
| 内存使用率 | < 60% | 75% | 90% |
| 磁盘使用率 | < 70% | 85% | 95% |
| 网络带宽 | < 50% | 75% | 90% |
| 数据库连接数 | < 30 | 40 | 50 |

### 12.5 联系信息

**技术支持：**
- 邮箱：support@intelligent-machining.com
- 电话：400-xxx-xxxx
- 在线支持：https://support.intelligent-machining.com

**开发团队：**
- 项目负责人：张三
- 技术架构师：李四
- 开发工程师：王五

**版本信息：**
- 当前版本：V1.0
- 发布日期：2024年12月
- 下一版本计划：V1.1 (预计2025年3月)

---

**文档结束**

*本操作手册将根据系统更新持续维护和完善。如有疑问或建议，请联系技术支持团队。*